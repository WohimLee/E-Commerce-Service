
## 第 4 步：在搜索引擎层（ElasticSearch）建索引与检索 API

### 一、 方向
#### 1 优先选 “只用 Elasticsearch/OpenSearch 做混合检索”

如果现在还在验证效果/迭代阶段，强烈建议先 ES/OpenSearch 单栈（BM25 + kNN 向量 + 结构化过滤 + RRF/加权融合），理由：

- 数据天然适合 ES：大量可枚举属性（season/scene/material/style/人群/颜色/尺码）→ ES 的 filter + aggregation 很强
- “导购”查询里关键词命中很常见（品牌、品类、颜色、场景词）→ BM25 很吃香
- ES/OpenSearch 已支持向量检索（HNSW / kNN），直接做 hybrid，工程复杂度最低（少一套 Milvus 的部署、同步、回源、融合排序）

#### 2 什么时候再上 Milvus？
当满足以下任意情况，再考虑 “Milvus + ES 双路”：

- 数据量很大（比如千万级 SKU），ES 的向量成本/性能不划算
- 需要更强的向量能力（多向量字段、向量量化、复杂召回策略、多集合隔离、低延迟高并发稳定性）
- 已经有成熟的 ES 检索，但想把向量召回单独做成可横向扩展的服务

#### 3 数据如何组织：以 SKU 为主文档，属性合并入同一条记录

现在的两份 jsonl 用 skuid 能 join 上（注意一个是 int，一个是 string，入库时统一成 keyword 字符串）。

##### 建议的索引设计（一个 SKU 一条文档）

index: `products_sku`

##### 字段建议

>标识
- skuid (keyword)
- spuid (keyword)

>文本检索（BM25）

- product_name (text + keyword 子字段)
- product_description (text)
- brand_name (text + keyword)
- group_name (text + keyword) // 类目/品类
- marketing_attributes (text)

>结构化过滤（全用 keyword 或 numeric）

- season (keyword[])
- scene (keyword[])
- material (keyword[])
- style (keyword[])
- people_gender (keyword[])
- age_range (keyword[])
- color (keyword[])
- size (keyword[])
- price (float)
- sales (int)

>向量（dense_vector / knn_vector）
- emb_text：把 product_name + group_name + brand_name + marketing_attributes + product_description +（结构化属性展开成文本） 拼成一段“检索用文本”再 embedding
- 例："连衣裙 德菲蒂奥 通勤 灰色 S …" 这种展开对导购很有效

不建议把属性单独放另一张“属性索引”再检索：最终要按 SKU 返回商品，分索引会增加 join / 回源复杂度，还会拉低延迟。

#### 4 只用 ES/OpenSearch 怎么做混合召回（推荐做法）
##### 1）检索流程（强建议）

1. Query 解析/改写：从用户句子里抽取结构化条件（颜色、尺码、性别、季节、场景、价格区间、品牌、品类）

2. filter 先行：把硬条件（如“黑色/XL/冬季/男童/价格<800”）用 bool.filter 限定候选集

3. hybrid 排序：在候选集里同时跑
    - BM25（multi_match：name/brand/group/desc/marketing）
    - kNN（emb_text）

4. 融合：用 `RRF（reciprocal rank fusion）` 或简单加权（比如 `0.6*bm25 + 0.4*vector`，再叠加业务分：销量/新品/利润等）

#### 2）为什么对这类数据特别合适
- `product_name` 和 `product_description` 信息密度高，BM25 很容易命中“通勤/赫本风/小黑裙/羽绒服/中长款”等词

product_attrs.jsonl 给的属性非常适合做 filter（season/scene/material/人群/颜色/尺码），能显著降低向量误召回


### 二、实施方案

#### 1) 索引与数据组织
##### 1.1 一条 SKU 一条文档（强推荐）

把两份数据按 skuid 合并成一个文档，核心字段：

- 基础：skuid, spuid, brand_name, group_name, product_name, marketing_attributes, product_description, price, sales
- 属性（可过滤）：season, scene, material, style, people_gender, age_range, color, size

- 向量字段：emb_text（dense_vector）

- 检索拼接文本：search_text（把 name/desc/属性展开拼一起，用于 embedding 生成）

注意：skuid 统一成字符串 keyword，避免 join/查询坑。

#### 2) Mapping（含中文分词、属性过滤、向量）

下面示例以 ES 8.x 为主（7.x 也大体类似）。中文分词用什么就替换 analyzer（ik / smartcn / jieba 插件等）；如果暂时没有中文分词插件，先用 standard 也能跑通，只是效果差一些。

>参考：`Tutorial/1.stage1/src/PUT_products_sku_v1.json`
- dims 按实际 embedding 维度改（768/1024/1536…）


#### 4) 查询总流程（RAG 混合召回）

目标：先过滤，再混合排序，再返回 topN 给 LLM 做导购话术。

##### 4.1 Query 解析（在的服务层做）

从用户 query 抽取硬条件（能过滤的都过滤）：

- 类目/品类：连衣裙、羽绒服、儿童衬衫…
- 品牌：德菲蒂奥、KELME…
- 颜色：黑/灰/浅蓝/经典黑/深灰色…
- 尺码：S/M/L/XL/3XL/120cm/35/40/45…
- 人群：女、男、男童、女童
- 季节：春夏秋冬/四季
- 场景：通勤/商务/户外/旅行/校园
- 价格区间：<800、800-1500、>1500

解析可以先规则/字典起步（电商导购足够好用），后面再上模型抽取。

#### 5) 混合检索 Query 模板（推荐：RRF 融合）

ES 里做真正的“BM25 + kNN 融合”最稳的是 RRF（Reciprocal Rank Fusion） 或者应用层融合。
如果的 ES 版本/发行版不支持 RRF，就走两次检索 + 应用层 RRF（很简单，后面给）。

##### 5.1 单次请求：kNN + query + filter（如果版本支持融合/检索里同时跑）

有些版本允许在一次请求里既跑文本 query 又跑 knn（并通过 rank/rrf 融合）。

>参考：`Tutorial/1.stage1/src/POST_products_sku_v1_search_mix.json`
- `k/num_candidates`：电商一般 `k=200~500`，`num_candidates=5~20*k`；再从 `size=50` 里给 RAG 用。
- ⚠️ 但：不同 ES / OpenSearch 发行版对“同请求融合”的支持不一致

#### 6) 两路检索 + 应用层 RRF 融合
##### 6.1 第一路：BM25（带 filter）
>参考：`Tutorial/1.stage1/src/POST_products_sku_v1_search_bm25.json`
##### 6.2 第二路：向量 kNN（同样带 filter）
>参考：`Tutorial/1.stage1/src/POST_products_sku_v1_search_knn.json`

##### 6.3 应用层 RRF 融合（推荐默认参数）

对两个 list（BM25 排名、Vector 排名）做：

- `rrf_score(doc) = Σ 1 / (k0 + rank_i(doc))`
- 经验：`k0=60` 很常用（也可 `20/60/100` 做 ab）

融合后取 topN（如 50），再做一次回源：
```
POST products_sku_v1/_mget
{
  "ids": ["771877","661584","..."]
}
```

为什么一定要回源？ 因为向量路只取 skuid 就够，减少网络/CPU；最终展示/生成回答才需要完整字段。

#### 7) 业务重排（导购很关键）

- 融合拿到候选后，再加一个轻量重排（应用层即可）：
- 如果用户明确“预算/价位带”，价格符合度加分
- 如果用户明确“场景/季节/人群”，匹配属性加分
- sales 可做轻权重（避免冷启动全 0 时影响太大）
- 新品/高毛利（如果有）可加权

例子（很粗暴但有效）：
```
final = 0.7*rrf + 0.2*attr_match + 0.1*log(1+sales)
```

#### 8) 给 RAG 的输出结构（建议）

给 LLM 的检索结果不要直接塞整段 description，建议结构化、可控长度：

每个候选商品给：

- `skuid, product_name, brand_name, group_name, price`
- `top_attrs`: season/scene/material/style/people_gender/color/size（最多 6~10 个）
- `short_desc`: 从 product_description 截取 120~200 字 + 关键卖点（或自己摘要）
- `why_match`:（可选）把命中词/匹配属性列出来，LLM 更会“导购解释”

#### 9) 默认参数组合（参考）
- Filter：能抽就抽（terms/range 全走 filter）
- BM25 size：200
- kNN：k=200，num_candidates=1500
- RRF：k0=60
- 返回给 RAG：top 30~50