## 检索精度


>generated_qeustions.jsonl
- 只调了 2 轮 prompt 生成的数据
- 加了运营的示例
```
K= 20 | n= 1500 | Hit@K=0.653 | MRR@K=0.408
```

>queries1
- 调了 2-3 小时 prompt 生成的数据
- 没加运营的示例
```
K=  1 | n=  1500 | Hit@K=0.851 | MRR@K=0.851
K=  5 | n=  1500 | Hit@K=0.984 | MRR@K=0.908
K= 10 | n=  1500 | Hit@K=0.994 | MRR@K=0.909
```

>queries2
- 调了 2-3 小时 prompt 生成的数据
- 加了运营的示例
```
K=  1 | n=  1525 | Hit@K=0.487 | MRR@K=0.487
K=  5 | n=  1525 | Hit@K=0.716 | MRR@K=0.577
K= 10 | n=  1525 | Hit@K=0.799 | MRR@K=0.588
```
### 一、逐项解释

#### 1️⃣ `n = 1500`

* 一共评测了 **1500 个 query**
* 每个 query 只有 **1 个正确 target**


#### 2️⃣ `Hit@20 = 0.653`

👉 **65.3% 的 query**：

* 在 **前 20 个结果里**
* **至少出现过一次正确商品**

换句话说：

> **约 2/3 的搜索请求，用户翻到第 2 页（20 条）以内能看到对的商品**


#### 3️⃣ `MRR@20 = 0.408`

👉 对这 1500 个 query：

* 正确商品的**平均倒数排名**是 **0.408**

把它还原成“平均排名”的直觉：

$$
\text{平均 rank} \approx \frac{1}{0.408} \approx 2.45
$$

⚠️ 注意：
这是 **“在命中的那些 query 上，且受 miss=0 拉低后的平均”**，不是严格意义的算术平均 rank，但直觉上很接近。



### 二、这两个数合在一起怎么解读？


#### 💡 关键结论

> **一旦命中，正确商品通常排得非常靠前（Top 3 左右）**
> **但有 34.7% 的 query 完全没召回到**

换成一句更直观的话：

* 排序（rerank / RRF / embedding 排前能力）：**不错**
* 召回（能不能把正确商品捞出来）：**是主要短板**

---

#### 用一个小表格看更清楚

假设 1500 个 query：

| 情况            | 数量（约） |
| ------------- | ----- |
| Top20 命中      | 980   |
| Top20 完全 miss | 520   |
| 命中时平均 rank    | ~2–3  |



### 三、这在搜索系统里算什么水平？

**在真实商品搜索/RAG 场景中：**

* **Hit@20 ≈ 0.65** →
  👉 *中等偏上，但离“可用上限”还有空间*
* **MRR@20 ≈ 0.41** →
  👉 *排序质量是明显优点*

这是 **Hybrid（BM25 + 向量 + RRF）** 的结果：

> **RRF / 排序策略是有效的，主要瓶颈在召回侧**



### 三、接下来你该优化什么？（非常实用）

#### ✅ 不要先动排序

MRR 已经不低了，动 RRF 很可能：

* MRR ↑ 一点点
* Hit@20 几乎不变

性价比低。



#### 🔥 应该优先做的事（按收益排序）

##### 1️⃣ 提升召回覆盖（最重要）

想办法把那 **35% miss 的 query** 捞进 Top20：

* ⬆️ `knn_k` / `num_candidates`
* ⬆️ `rrf_rank_window_size`
* 检查 embedding 字段是否覆盖了用户真实表达
* 对 miss query 做抽样，看：

  * 是词不在索引？
  * 语义偏差？
  * filter 过严？


##### 2️⃣ 看分桶指标（强烈建议）

比如：

* Hit@5 / Hit@10 / Hit@20
* MRR@5 / MRR@10

你很可能会看到：

```
Hit@5   ≈ 0.55
Hit@10  ≈ 0.62
Hit@20  ≈ 0.65
```

👉 这说明 **召回在 10→20 提升有限**，可能不是窗口问题，而是召回源缺失。

---

##### 3️⃣ 专门分析 miss 的 520 条 query

非常关键，建议你直接做：

```python
if rank is None:
    dump.append(q)
```

然后人工看 50 条，通常会立刻发现规律：

* 长尾属性没进 embedding
* 指代 / 同义词 / 别名 / 
* SKU 级 vs SPU 级混淆
* filter 条件太严格

