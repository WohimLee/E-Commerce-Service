## Elastic Search 实现
- 9.1.3
#### 0) 这个版本最推荐用的能力：Retriever + RRF

ES 支持在一次 `_search` 里用 `retriever.rrf` 把多个子检索（比如 BM25 的 standard + 向量的 knn）融合成一个最终排序结果；rank_constant 默认 60，rank_window_size 控制每路参与融合的候选窗口。


#### 1) 索引设计（关键点）
##### 1.1 一条 SKU 一条文档（现在的数据非常适合）

把 data/opensearch_product_data.jsonl 和 output/product_attrs.jsonl 按 skuid 合并进同一条文档，并额外存：
- search_text：把 name/desc/marketing + 结构化属性展开成文本（用于 embedding）
- emb_text：dense_vector（离线生成 embedding 写入）

##### 1.2 Mapping（示例）

中文分词可以后面换成 IK 等；先跑通链路最重要。dims 改成的 embedding 维度。
```json
PUT products_sku_v1
{
  "mappings": {
    "properties": {
      "skuid": { "type": "keyword" },
      "spuid": { "type": "keyword" },

      "brand_name": { "type": "text", "fields": { "kw": { "type": "keyword" } } },
      "group_name": { "type": "text", "fields": { "kw": { "type": "keyword" } } },
      "product_name": { "type": "text" },
      "marketing_attributes": { "type": "text" },
      "product_description": { "type": "text" },

      "price": { "type": "float" },
      "sales": { "type": "integer" },

      "season": { "type": "keyword" },
      "scene": { "type": "keyword" },
      "material": { "type": "keyword" },
      "style": { "type": "keyword" },
      "people_gender": { "type": "keyword" },
      "age_range": { "type": "keyword" },
      "color": { "type": "keyword" },
      "size": { "type": "keyword" },

      "search_text": { "type": "text" },

      "emb_text": {
        "type": "dense_vector",
        "dims": 1024,
        "index": true,
        "similarity": "cosine"
      }
    }
  }
}
```
#### 2) 线上检索流程（建议照这个固定成“契约”）

Query → 条件抽取 → filter → RRF(standard + knn) → topN → 给 RAG
- 条件抽取：颜色、尺码、人群、季节、场景、价格区间、品牌/品类
- filter 一定要两路都加（否则向量路会把无关类目捞进来）

#### 3) 一次请求完成混合召回：RRF + (BM25 standard) + (kNN)

下面是电商导购最常用的模板（直接可用）：

##### 3.1 请求模板（核心）
```py
POST products_sku_v1/_search
{
  "size": 50,
  "track_total_hits": false,
  "_source": [
    "skuid","spuid","brand_name","group_name","product_name",
    "price","sales","season","scene","material","style",
    "people_gender","age_range","color","size"
  ],
  "retriever": {
    "rrf": {
      "rank_constant": 60,
      "rank_window_size": 200,
      "retrievers": [
        {
          "standard": {
            "query": {
              "bool": {
                "filter": [
                  { "terms": { "season": ["冬季"] } },
                  { "terms": { "people_gender": ["女"] } },
                  { "range": { "price": { "lte": 1500 } } }
                ],
                "must": [
                  {
                    "multi_match": {
                      "query": "通勤 小黑裙",
                      "fields": [
                        "product_name^4",
                        "brand_name^2",
                        "group_name^2",
                        "marketing_attributes^1.5",
                        "product_description",
                        "search_text^2"
                      ],
                      "type": "best_fields"
                    }
                  }
                ]
              }
            }
          }
        },
        {
          "knn": {
            "field": "emb_text",
            "query_vector": [/* 的 query embedding */],
            "k": 200,
            "num_candidates": 1500,
            "filter": [
              { "terms": { "season": ["冬季"] } },
              { "terms": { "people_gender": ["女"] } },
              { "range": { "price": { "lte": 1500 } } }
            ]
          }
        }
      ]
    }
  }
}
```

说明：
- retriever.rrf 的用法、rank_constant/rank_window_size 的含义与默认值在官方文档里有明确说明。
- kNN 检索支持 filter 来限制可匹配文档集合（这里用于“属性硬约束”非常关键）。

#### 4) 参数怎么定（电商导购的“默认好用值”）

- size = 30~80：给 RAG 的候选（通常 50 足够）
- rank_window_size = 100~300：两路各拿这么多参与融合（越大越准但越慢）
- rank_constant = 60：默认就很好（别急着调）
- k = 100~300，num_candidates = 5~10*k：向量路常用区间；num_candidates 越大召回越准但更慢（是主要旋钮）


#### 5) 给 RAG 的输出建议（避免塞爆上下文）

每个商品给 LLM 这些字段就够生成导购话术了：

- product_name / brand_name / group_name / price
- 结构化属性：season, scene, material, style, people_gender, color, size
- （可选）再拼一个 reason_tags：把命中的过滤条件/关键词列出来，LLM 更会“解释为什么推荐”